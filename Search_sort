/排序 
bubbleSort(int arr[], int n )
{
	bool swapped = true;
	int j = 0;
	int tmp;
	while(swapped ) {
		swapped = false;
		j++;
		//每次都会有一个定型(最后一个，最大的一个)，在这里是最大的一个。所以n-j
		for(int i =0; i < n-j; i++){
			if(arr[i] < arr[i+1]){
			tmp = arr[i];
			arr[i] = arr[i+1];
			arr[i+1] = tmp;
			swapped =true;
			}
		}	
	}
}


quick_sort

void quickSort(int arr[], int left, int right) {

      int i = left, j = right;
      int tmp;
      int pivot = arr[(left + right) / 2];
      /* partition */
      while (i <= j) {
            while (arr[i] < pivot)
                  i++;
            while (arr[j] > pivot)
                  j--;
			//由于还没到下次判断 ，所以还是要检测范围。
            if (i <= j) {
                  tmp = arr[i];
                  arr[i] = arr[j];
                  arr[j] = tmp;
                  i++;
                  j--;
		  }
      };
      /* recursion */
      if (left < j)
            quickSort(arr, left, j);
      if (i < right)
            quickSort(arr, i, right);
}



void selectionSort(int arr[], int n) {
      int i, j, minIndex, tmp;    
      for (i = 0; i < n - 1; i++) {
            minIndex = i;
            for (j = i + 1; j < n; j++)//两具index都在变化 
                  if (arr[j] < arr[minIndex])
                        minIndex = j;
            if (minIndex != i) { //出来了并不确定是否是这样的。找到了更小的值 
                  tmp = arr[i];
                  arr[i] = arr[minIndex];
                  arr[minIndex] = tmp;  /找到了最小的值放在最前面，初始的地址进一。			  

            }
      }
}


void insertsort(int *arr, int len ){
	int temp;
	int len = len ;
	int j =0;// 避免重复地定义 int j ;
	for(int i =1; i<len ; i++ )
	{
		j = i ;		
		while( j> 0 && arr[j-1] > arr[j] ){
		
				temp = arr[j];
				arr[j] =arr[j-1];
				arr[j -1] =temp ;
				j--;
		}	
	}
}	


//迭代版本
long long Fibonacci(unsigned n)
{
    int result[2] = {0, 1};
    
    if(n < 2){
        return result[n];
    }
    
    long long  fibNMinusOne = 1;
    long long  fibNMinusTwo = 0;
    
    long long  fibN = 0;
    
    for(unsigned int i = 2; i <= n; ++ i){
        
        fibN = fibNMinusOne + fibNMinusTwo;
        
        fibNMinusTwo = fibNMinusOne;
        fibNMinusOne = fibN;
    }
    
    return fibN;
}
Java// 递归版本
public static int Fibonacci( int n ){

    if( n==0 || n==1 ){
         return 1;
    }
    else if(n>1){

        return Fibonacci(n-1)+Fibonacci(n-2);
    }
    else{
    
        return 0;
    }
}
//两分法，得有序
int binarySearch(int arr[], int value, int left, int right) {

      while (left <= right) {

            int middle = (left + right) / 2;

            if (arr[middle] == value)

                  return middle;

            else if (arr[middle] > value)

                  right = middle - 1;

            else

                  left = middle + 1;

      }

      return -1;

}

//归并排序

// m - size of A

// n - size of B

// size of C array must be equal or greater than

// m + n

void merge(int m, int n, int A[], int B[], int C[]) {

      int i, j, k;

      i = 0;

      j = 0;

      k = 0;

      while (i < m && j < n) {

            if (A[i] <= B[j]) {

                  C[k] = A[i];

                  i++;

            } else {

                  C[k] = B[j];

                  j++;

            }

            k++;

      }

      if (i < m) {

            for (int p = i; p < m; p++) {

                  C[k] = A[p];

                  k++;

            }

      } else {

            for (int p = j; p < n; p++) {

                  C[k] = B[p];

                  k++;

            }

      }

}



bool isPrime(int number) {

      if (number == 1)

            return false;

      if (number == 2)

            return true;

      if (number % 2 == 0)

            return false;

      for (int d = 3; d <= (int)sqrt((double)number); d++)

            if (number % d == 0)

                  return false;

      return true;

}


